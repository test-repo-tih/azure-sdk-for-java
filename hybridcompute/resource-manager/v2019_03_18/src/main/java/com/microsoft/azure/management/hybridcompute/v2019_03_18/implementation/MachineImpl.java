/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 */

package com.microsoft.azure.management.hybridcompute.v2019_03_18.implementation;

import com.microsoft.azure.arm.resources.models.implementation.GroupableResourceCoreImpl;
import com.microsoft.azure.management.hybridcompute.v2019_03_18.Machine;
import rx.Observable;
import com.microsoft.azure.management.hybridcompute.v2019_03_18.MachineUpdate;
import com.microsoft.azure.management.hybridcompute.v2019_03_18.OSProfile;
import com.microsoft.azure.management.hybridcompute.v2019_03_18.StatusTypes;
import org.joda.time.DateTime;
import java.util.List;
import com.microsoft.azure.management.hybridcompute.v2019_03_18.ErrorDetail;
import rx.functions.Func1;

class MachineImpl extends GroupableResourceCoreImpl<Machine, MachineInner, MachineImpl, HybridComputeManager> implements Machine, Machine.Definition, Machine.Update {
    private MachineUpdate updateParameter;
    MachineImpl(String name, MachineInner inner, HybridComputeManager manager) {
        super(name, inner, manager);
        this.updateParameter = new MachineUpdate();
    }

    @Override
    public Observable<Machine> createResourceAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.createOrUpdateAsync(this.resourceGroupName(), this.name(), this.inner())
            .map(new Func1<MachineInner, MachineInner>() {
               @Override
               public MachineInner call(MachineInner resource) {
                   resetCreateUpdateParameters();
                   return resource;
               }
            })
            .map(innerToFluentMap(this));
    }

    @Override
    public Observable<Machine> updateResourceAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.updateAsync(this.resourceGroupName(), this.name(), this.updateParameter)
            .map(new Func1<MachineInner, MachineInner>() {
               @Override
               public MachineInner call(MachineInner resource) {
                   resetCreateUpdateParameters();
                   return resource;
               }
            })
            .map(innerToFluentMap(this));
    }

    @Override
    protected Observable<MachineInner> getInnerAsync() {
        MachinesInner client = this.manager().inner().machines();
        return client.getByResourceGroupAsync(this.resourceGroupName(), this.name());
    }

    @Override
    public boolean isInCreateMode() {
        return this.inner().id() == null;
    }

    private void resetCreateUpdateParameters() {
        this.updateParameter = new MachineUpdate();
    }

    @Override
    public String agentVersion() {
        return this.inner().agentVersion();
    }

    @Override
    public String clientPublicKey() {
        return this.inner().clientPublicKey();
    }

    @Override
    public String displayName() {
        return this.inner().displayName();
    }

    @Override
    public List<ErrorDetail> errorDetails() {
        return this.inner().errorDetails();
    }

    @Override
    public DateTime lastStatusChange() {
        return this.inner().lastStatusChange();
    }

    @Override
    public String machineFqdn() {
        return this.inner().machineFqdn();
    }

    @Override
    public String osName() {
        return this.inner().osName();
    }

    @Override
    public OSProfile osProfile() {
        return this.inner().osProfile();
    }

    @Override
    public String osVersion() {
        return this.inner().osVersion();
    }

    @Override
    public String physicalLocation() {
        return this.inner().physicalLocation();
    }

    @Override
    public String principalId() {
        return this.inner().principalId();
    }

    @Override
    public String provisioningState() {
        return this.inner().provisioningState();
    }

    @Override
    public StatusTypes status() {
        return this.inner().status();
    }

    @Override
    public String tenantId() {
        return this.inner().tenantId();
    }

    @Override
    public String type1() {
        return this.inner().type1();
    }

    @Override
    public String vmId() {
        return this.inner().vmId();
    }

    @Override
    public MachineImpl withClientPublicKey(String clientPublicKey) {
        this.inner().withClientPublicKey(clientPublicKey);
        return this;
    }

    @Override
    public MachineImpl withOsProfile(OSProfile osProfile) {
        this.inner().withOsProfile(osProfile);
        return this;
    }

    @Override
    public MachineImpl withType1(String type1) {
        this.inner().withType1(type1);
        return this;
    }

    @Override
    public MachineImpl withPhysicalLocation(String physicalLocation) {
        if (isInCreateMode()) {
            this.inner().withPhysicalLocation(physicalLocation);
        } else {
            this.updateParameter.withPhysicalLocation(physicalLocation);
        }
        return this;
    }

}
